import Util from "./Util";
import CoordCube from "./CoordCube";

export default class CubieCube {
  /**
   * 16 symmetries generated by S_F2, S_U4 and S_LR2
   */
  static SymCube: CubieCube[] = [];

  /**
   * 18 move cubes
   */
  static MoveCube: CubieCube[] = [];

  static MoveCubeSym: number[] = [];
  static FirstMoveSym: number[] = [];

  static SymMult: number[][] = [];
  static SymMultInv: number[][] = [];
  static SymMove: number[][] = [];

  static Sym8Move: number[] = [];
  static SymMoveUD: number[][] = [];

  /**
   * ClassIndexToRepresentantArrays
   */
  static FlipS2R: number[] = [];
  static TwistS2R: number[] = [];
  static EPermS2R: number[] = [];
  static Perm2CombP: number[] = [];
  static PermInvEdgeSym: number[] = [];
  static MPermInv: number[] = [];

  /**
   * Notice that Edge Perm Coordnate and Corner Perm Coordnate are the same symmetry structure.
   * So their ClassIndexToRepresentantArray are the same.
   * And when x is RawEdgePermCoordnate, y*16+k is SymEdgePermCoordnate, y*16+(k^e2c[k]) will
   * be the SymCornerPermCoordnate of the State whose RawCornerPermCoordnate is x.
   */
  // static byte[] e2c = {0, 0, 0, 0, 1, 3, 1, 3, 1, 3, 1, 3, 0, 0, 0, 0};
  static SYM_E2C_MAGIC = 0x00dddd00;
  static ESym2CSym(idx: number): number {
    return idx ^ ((CubieCube.SYM_E2C_MAGIC >> ((idx & 0xf) << 1)) & 3);
  }

  /**
   * Raw-Coordnate to Sym-Coordnate, only for speeding up initializaion.
   */
  static FlipR2S: number[] = [];
  static TwistR2S: number[] = [];
  static EPermR2S: number[] = [];

  /**
   *
   */
  static SymStateTwist: number[] = [];
  static SymStateFlip: number[] = [];
  static SymStatePerm: number[] = [];

  static URF1: CubieCube = new CubieCube(2531, 1373, 67026819, 1367);
  static URF2: CubieCube = new CubieCube(2089, 1906, 322752913, 2040);
  static URFMove = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
    [6, 7, 8, 0, 1, 2, 3, 4, 5, 15, 16, 17, 9, 10, 11, 12, 13, 14],
    [3, 4, 5, 6, 7, 8, 0, 1, 2, 12, 13, 14, 15, 16, 17, 9, 10, 11],
    [2, 1, 0, 5, 4, 3, 8, 7, 6, 11, 10, 9, 14, 13, 12, 17, 16, 15],
    [8, 7, 6, 2, 1, 0, 5, 4, 3, 17, 16, 15, 11, 10, 9, 14, 13, 12],
    [5, 4, 3, 8, 7, 6, 2, 1, 0, 14, 13, 12, 17, 16, 15, 11, 10, 9],
  ];

  static InitMove(): void {
    const result: CubieCube[] = [];
    result[0] = new CubieCube(15120, 0, 119750400, 0);
    result[3] = new CubieCube(21021, 1494, 323403417, 0);
    result[6] = new CubieCube(8064, 1236, 29441808, 550);
    result[9] = new CubieCube(9, 0, 5880, 0);
    result[12] = new CubieCube(1230, 412, 2949660, 0);
    result[15] = new CubieCube(224, 137, 328552, 137);
    for (let a = 0; a < 18; a += 3) {
      for (let p = 0; p < 2; p++) {
        result[a + p + 1] = new CubieCube();
        CubieCube.EdgeMult(result[a + p], result[a], result[a + p + 1]);
        CubieCube.CornMult(result[a + p], result[a], result[a + p + 1]);
      }
    }
    CubieCube.MoveCube = result;
  }

  static InitSym(): void {
    let c = new CubieCube();
    let d = new CubieCube();
    const f2 = new CubieCube(28783, 0, 259268407, 0);
    const u4 = new CubieCube(15138, 0, 119765538, 7);
    const lr2 = new CubieCube(5167, 0, 83473207, 0);
    for (let i = 0; i < 8; i++) {
      lr2.ca[i] |= 3 << 3;
    }

    for (let i = 0; i < 16; i++) {
      CubieCube.SymCube[i] = new CubieCube();
      CubieCube.SymCube[i].copy(c);
      CubieCube.CornMultFull(c, u4, d);
      CubieCube.EdgeMult(c, u4, d);
      [c, d] = [d, c];
      if (i % 4 == 3) {
        CubieCube.CornMultFull(c, lr2, d);
        CubieCube.EdgeMult(c, lr2, d);
        [c, d] = [d, c];
      }
      if (i % 8 == 7) {
        CubieCube.CornMultFull(c, f2, d);
        CubieCube.EdgeMult(c, f2, d);
        [c, d] = [d, c];
      }
    }
    for (let i = 0; i < 16; i++) {
      CubieCube.SymMult[i] = [];
      CubieCube.SymMultInv[i] = [];
      CubieCube.SymMove[i] = [];
      CubieCube.SymMoveUD[i] = [];
    }
    for (let i = 0; i < 16; i++) {
      for (let j = 0; j < 16; j++) {
        CubieCube.SymMult[i][j] = i ^ j ^ ((0x14ab4 >> j) & (i << 1) & 2); // SymMult[i][j] = (i ^ j ^ (0x14ab4 >> j & i << 1 & 2)));
        CubieCube.SymMultInv[CubieCube.SymMult[i][j]][j] = i;
      }
    }

    for (let s = 0; s < 16; s++) {
      for (let j = 0; j < 18; j++) {
        CubieCube.CornConjugate(CubieCube.MoveCube[j], CubieCube.SymMultInv[0][s], c);
        outloop: for (let m = 0; m < 18; m++) {
          for (let t = 0; t < 8; t++) {
            if (CubieCube.MoveCube[m].ca[t] != c.ca[t]) {
              continue outloop;
            }
          }
          CubieCube.SymMove[s][j] = m;
          CubieCube.SymMoveUD[s][Util.STD2UD[j]] = Util.STD2UD[m];
          break;
        }
        if (s % 2 == 0) {
          CubieCube.Sym8Move[(j << 3) | (s >> 1)] = CubieCube.SymMove[s][j];
        }
      }
    }
  }

  static InitSym2Raw(N_RAW: number, Sym2Raw: number[], Raw2Sym: number[], SymState: number[], coord: number): number {
    const c = new CubieCube();
    const d = new CubieCube();
    let count = 0,
      idx = 0;
    const symInc = coord >= 2 ? 1 : 2;
    const isEdge = coord != 1;

    for (let i = 0; i < N_RAW; i++) {
      if (Raw2Sym[i] != undefined) {
        continue;
      }
      switch (coord) {
        case 0:
          c.Flip = i;
          break;
        case 1:
          c.Twist = i;
          break;
        case 2:
          c.EPerm = i;
          break;
      }
      for (let s = 0; s < 16; s += symInc) {
        if (isEdge) {
          CubieCube.EdgeConjugate(c, s, d);
        } else {
          CubieCube.CornConjugate(c, s, d);
        }
        switch (coord) {
          case 0:
            idx = d.Flip;
            break;
          case 1:
            idx = d.Twist;
            break;
          case 2:
            idx = d.EPerm;
            break;
        }
        if (idx == i) {
          SymState[count] |= 1 << (s / symInc);
        }
        Raw2Sym[idx] = ((count << 4) | s) / symInc;
      }
      Sym2Raw[count++] = i;
    }
    return count;
  }

  static InitFlipSym2Raw(): void {
    CubieCube.InitSym2Raw(CoordCube.N_FLIP, CubieCube.FlipS2R, CubieCube.FlipR2S, CubieCube.SymStateFlip, 0);
  }

  static InitTwistSym2Raw(): void {
    CubieCube.InitSym2Raw(CoordCube.N_TWIST, CubieCube.TwistS2R, CubieCube.TwistR2S, CubieCube.SymStateTwist, 1);
  }

  static InitPermSym2Raw(): void {
    CubieCube.InitSym2Raw(CoordCube.N_PERM, CubieCube.EPermS2R, CubieCube.EPermR2S, CubieCube.SymStatePerm, 2);
    const cc = new CubieCube();
    for (let i = 0; i < CoordCube.N_PERM_SYM; i++) {
      cc.EPerm = CubieCube.EPermS2R[i];
      CubieCube.Perm2CombP[i] = Util.GetComb(cc.ea, 0, true);
      cc.inverse();
      CubieCube.PermInvEdgeSym[i] = cc.EPermSym;
    }
    for (let i = 0; i < CoordCube.N_MPERM; i++) {
      cc.MPerm = i;
      cc.inverse();
      CubieCube.MPermInv[i] = cc.MPerm;
    }
  }

  static Init(): void {
    CubieCube.temps = new CubieCube();
    CubieCube.InitMove();
    CubieCube.InitSym();
  }

  /**
   * prod = a * b, Corner Only.
   */
  static CornMult(a: CubieCube, b: CubieCube, prod: CubieCube): void {
    for (let corn = 0; corn < 8; corn++) {
      const oriA = a.ca[b.ca[corn] & 7] >> 3;
      const oriB = b.ca[corn] >> 3;
      prod.ca[corn] = (a.ca[b.ca[corn] & 7] & 7) | ((oriA + oriB) % 3 << 3);
    }
  }

  /**
   * prod = a * b, Corner Only. With mirrored cases considered
   */
  static CornMultFull(a: CubieCube, b: CubieCube, prod: CubieCube): void {
    for (let corn = 0; corn < 8; corn++) {
      const oriA = a.ca[b.ca[corn] & 7] >> 3;
      const oriB = b.ca[corn] >> 3;
      let ori = oriA + (oriA < 3 ? oriB : 6 - oriB);
      ori = (ori % 3) + (oriA < 3 == oriB < 3 ? 0 : 3);
      prod.ca[corn] = (a.ca[b.ca[corn] & 7] & 7) | (ori << 3);
    }
  }

  /**
   * prod = a * b, Edge Only.
   */
  static EdgeMult(a: CubieCube, b: CubieCube, prod: CubieCube): void {
    for (let ed = 0; ed < 12; ed++) {
      prod.ea[ed] = a.ea[b.ea[ed] >> 1] ^ (b.ea[ed] & 1);
    }
  }

  /**
   * b = S_idx^-1 * a * S_idx, Corner Only.
   */
  static CornConjugate(a: CubieCube, idx: number, b: CubieCube): void {
    const sinv: CubieCube = CubieCube.SymCube[CubieCube.SymMultInv[0][idx]];
    const s = CubieCube.SymCube[idx];
    for (let corn = 0; corn < 8; corn++) {
      const oriA = sinv.ca[a.ca[s.ca[corn] & 7] & 7] >> 3;
      const oriB = a.ca[s.ca[corn] & 7] >> 3;
      const ori = oriA < 3 ? oriB : (3 - oriB) % 3;
      b.ca[corn] = (sinv.ca[a.ca[s.ca[corn] & 7] & 7] & 7) | (ori << 3);
    }
  }

  /**
   * b = S_idx^-1 * a * S_idx, Edge Only.
   */
  static EdgeConjugate(a: CubieCube, idx: number, b: CubieCube): void {
    const sinv = CubieCube.SymCube[CubieCube.SymMultInv[0][idx]];
    const s = CubieCube.SymCube[idx];
    for (let ed = 0; ed < 12; ed++) {
      b.ea[ed] = sinv.ea[a.ea[s.ea[ed] >> 1] >> 1] ^ (a.ea[s.ea[ed] >> 1] & 1) ^ (s.ea[ed] & 1);
    }
  }

  static GetPermSymInv(idx: number, sym: number, corner: boolean): number {
    let idxi = CubieCube.PermInvEdgeSym[idx];
    if (corner) {
      idxi = CubieCube.ESym2CSym(idxi);
    }
    return (idxi & 0xfff0) | CubieCube.SymMult[idxi & 0xf][sym];
  }

  static GetSkipMoves(ssym: number): number {
    let ret = 0;
    for (let i = 1; (ssym >>= 1) != 0; i++) {
      if ((ssym & 1) == 1) {
        ret |= CubieCube.FirstMoveSym[i];
      }
    }
    return ret;
  }

  ca: number[] = [0, 1, 2, 3, 4, 5, 6, 7];
  ea: number[] = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22];
  static temps: CubieCube;

  constructor(cperm = 0, twist = 0, eperm = 0, flip = 0) {
    this.CPerm = cperm;
    this.Twist = twist;
    Util.SetNPermFull(this.ea, eperm, 12, true);
    this.Flip = flip;
  }

  copy(c: CubieCube): void {
    for (let edge = 0; edge < 12; edge++) {
      this.ea[edge] = c.ea[edge];
    }
    for (let corn = 0; corn < 8; corn++) {
      this.ca[corn] = c.ca[corn];
    }
  }

  inverse(): void {
    for (let edge = 0; edge < 12; edge++) {
      CubieCube.temps.ea[this.ea[edge] >> 1] = (edge << 1) | (this.ea[edge] & 1);
    }
    for (let corn = 0; corn < 8; corn++) {
      CubieCube.temps.ca[this.ca[corn] & 0x7] = corn | ((0x20 >> (this.ca[corn] >> 3)) & 0x18);
    }
    this.copy(CubieCube.temps);
  }

  /**
   * this = S_urf^-1 * this * S_urf.
   */
  URFConjugate(): void {
    CubieCube.CornMult(CubieCube.URF2, this, CubieCube.temps);
    CubieCube.CornMult(CubieCube.temps, CubieCube.URF1, this);
    CubieCube.EdgeMult(CubieCube.URF2, this, CubieCube.temps);
    CubieCube.EdgeMult(CubieCube.temps, CubieCube.URF1, this);
  }

  // ********************************************* Get and set coordinates *********************************************
  // XSym : Symmetry Coordnate of X. MUST be called after initialization of ClassIndexToRepresentantArrays.

  // ++++++++++++++++++++ Phase 1 Coordnates ++++++++++++++++++++
  // Flip : Orientation of 12 Edges. Raw[0, 2048) Sym[0, 336 * 8)
  // Twist : Orientation of 8 Corners. Raw[0, 2187) Sym[0, 324 * 8)
  // UDSlice : Positions of the 4 UDSlice edges, the order is ignored. [0, 495)

  get Flip(): number {
    let idx = 0;
    for (let i = 0; i < 11; i++) {
      idx = (idx << 1) | (this.ea[i] & 1);
    }
    return idx;
  }

  set Flip(idx: number) {
    let parity = 0;
    let val = 0;
    for (let i = 10; i >= 0; i--, idx >>= 1) {
      parity ^= val = idx & 1;
      this.ea[i] = (this.ea[i] & ~1) | val;
    }
    this.ea[11] = (this.ea[11] & ~1) | parity;
  }

  get FlipSym(): number {
    return CubieCube.FlipR2S[this.Flip];
  }

  get Twist(): number {
    let idx = 0;
    for (let i = 0; i < 7; i++) {
      idx += (idx << 1) + (this.ca[i] >> 3);
    }
    return idx;
  }

  set Twist(idx) {
    let twst = 15;
    let val = 0;
    for (let i = 6; i >= 0; i--, idx = ~~(idx / 3)) {
      twst -= val = idx % 3;
      this.ca[i] = (this.ca[i] & 0x7) | (val << 3);
    }
    this.ca[7] = (this.ca[7] & 0x7) | (twst % 3 << 3);
  }

  get TwistSym(): number {
    return CubieCube.TwistR2S[this.Twist];
  }

  get UDSlice(): number {
    return 494 - Util.GetComb(this.ea, 8, true);
  }

  set UDSlice(idx) {
    Util.SetComb(this.ea, 494 - idx, 8, true);
  }

  // ++++++++++++++++++++ Phase 2 Coordnates ++++++++++++++++++++
  // EPerm : Permutations of 8 UD Edges. Raw[0, 40320) Sym[0, 2187 * 16)
  // Cperm : Permutations of 8 Corners. Raw[0, 40320) Sym[0, 2187 * 16)
  // MPerm : Permutations of 4 UDSlice Edges. [0, 24)

  get CPerm(): number {
    return Util.GetNPerm(this.ca, 8, false);
  }

  set CPerm(idx) {
    Util.SetNPerm(this.ca, idx, 8, false);
  }

  get CPermSym(): number {
    return CubieCube.ESym2CSym(CubieCube.EPermR2S[this.CPerm]);
  }

  get EPerm(): number {
    return Util.GetNPerm(this.ea, 8, true);
  }

  set EPerm(idx) {
    Util.SetNPerm(this.ea, idx, 8, true);
  }

  get EPermSym(): number {
    return CubieCube.EPermR2S[this.EPerm];
  }

  get MPerm(): number {
    return Util.GetNPermFull(this.ea, 12, true) % 24;
  }

  set MPerm(idx) {
    Util.SetNPermFull(this.ea, idx, 12, true);
  }

  get CComb(): number {
    return Util.GetComb(this.ca, 0, false);
  }

  set CComb(idx) {
    Util.SetComb(this.ca, idx, 0, false);
  }

  verify(): string {
    let sum = 0;
    let mask = 0;
    for (let e = 0; e < 12; e++) {
      mask |= 1 << (this.ea[e] >> 1);
      sum ^= this.ea[e] & 1;
    }
    if (mask != 0xfff) {
      return "missing edges";
    }
    if (sum != 0) {
      return "fliped edges";
    }
    mask = 0;
    sum = 0;
    for (let c = 0; c < 8; c++) {
      mask |= 1 << (this.ca[c] & 7);
      sum += this.ca[c] >> 3;
    }
    if (mask != 0xff) {
      return "missing corners";
    }
    if (sum % 3 != 0) {
      return "twisted corner";
    }
    if ((Util.GetNParity(Util.GetNPermFull(this.ea, 12, true), 12) ^ Util.GetNParity(this.CPerm, 8)) != 0) {
      return "parity error";
    }
    return "";
  }

  serialize(): string {
    const ts = "URFDLB";
    const f = [];
    for (let i = 0; i < 54; i++) {
      f[i] = ts[~~(i / 9)];
    }
    for (let c = 0; c < 8; c++) {
      const j = this.ca[c] & 0x7; // cornercubie with index j is at
      const ori = this.ca[c] >> 3; // Orientation of this cubie
      for (let n = 0; n < 3; n++) f[Util.CornerFacelet[c][(n + ori) % 3]] = ts[~~(Util.CornerFacelet[j][n] / 9)];
    }
    for (let e = 0; e < 12; e++) {
      const j = this.ea[e] >> 1; // edgecubie with index j is at edgeposition
      const ori = this.ea[e] & 1; // Orientation of this cubie
      for (let n = 0; n < 2; n++) f[Util.EdgeFacelet[e][(n + ori) % 2]] = ts[~~(Util.EdgeFacelet[j][n] / 9)];
    }
    return f.join("");
  }

  deserialize(facelet: string): boolean {
    let count = 0;
    const f = [];
    const centers = facelet[4] + facelet[13] + facelet[22] + facelet[31] + facelet[40] + facelet[49];
    for (let i = 0; i < 54; ++i) {
      f[i] = centers.indexOf(facelet[i]);
      if (f[i] == -1) {
        return false;
      }
      count += 1 << (f[i] << 2);
    }
    if (count != 0x999999) {
      return false;
    }
    let col1, col2, i, j, ori;
    for (i = 0; i < 8; ++i) {
      for (ori = 0; ori < 3; ++ori) if (f[Util.CornerFacelet[i][ori]] == 0 || f[Util.CornerFacelet[i][ori]] == 3) break;
      col1 = f[Util.CornerFacelet[i][(ori + 1) % 3]];
      col2 = f[Util.CornerFacelet[i][(ori + 2) % 3]];
      for (j = 0; j < 8; ++j) {
        if (col1 == ~~(Util.CornerFacelet[j][1] / 9) && col2 == ~~(Util.CornerFacelet[j][2] / 9)) {
          this.ca[i] = j | (ori % 3 << 3);
          break;
        }
      }
    }
    for (i = 0; i < 12; ++i) {
      for (j = 0; j < 12; ++j) {
        if (
          f[Util.EdgeFacelet[i][0]] == ~~(Util.EdgeFacelet[j][0] / 9) &&
          f[Util.EdgeFacelet[i][1]] == ~~(Util.EdgeFacelet[j][1] / 9)
        ) {
          this.ea[i] = j << 1;
          break;
        }
        if (
          f[Util.EdgeFacelet[i][0]] == ~~(Util.EdgeFacelet[j][1] / 9) &&
          f[Util.EdgeFacelet[i][1]] == ~~(Util.EdgeFacelet[j][0] / 9)
        ) {
          this.ea[i] = (j << 1) | 1;
          break;
        }
      }
    }
    return true;
  }
}
